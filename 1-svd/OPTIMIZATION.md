# SVDä½œä¸šä¼˜åŒ–è¯´æ˜

## ä¼˜åŒ–æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è¯´æ˜äº†å¯¹åŸå§‹ `work.py` çš„ä¼˜åŒ–å†…å®¹ï¼Œåˆ›å»ºäº†ä¼˜åŒ–ç‰ˆæœ¬ `work_optimized.py`ã€‚

## ä¸»è¦ä¼˜åŒ–ç‚¹

### 1. ä»£ç ç»“æ„é‡æ„ âœ…

**ä¼˜åŒ–å‰ï¼š**
- æ‰€æœ‰ä»£ç åœ¨ä¸€ä¸ªä¸»æµç¨‹ä¸­ï¼Œæ²¡æœ‰å‡½æ•°å°è£…
- ä»£ç å¤ç”¨æ€§å·®ï¼Œéš¾ä»¥æµ‹è¯•å’Œç»´æŠ¤

**ä¼˜åŒ–åï¼š**
- å°†æ ¸å¿ƒåŠŸèƒ½æ‹†åˆ†ä¸ºç‹¬ç«‹å‡½æ•°ï¼š
  - `create_sparse_matrix()` - ç¨€ç–çŸ©é˜µç”Ÿæˆ
  - `perform_svd_decomposition()` - SVDåˆ†è§£ä¸é™ç»´
  - `find_non_intersecting_rows_optimized()` - æŸ¥æ‰¾æ— äº¤é›†è¡Œ
  - `calculate_similarity_metrics()` - ç›¸ä¼¼åº¦è®¡ç®—
  - `print_section()` / `print_subsection()` - æ ¼å¼åŒ–è¾“å‡º
  - `main()` - ä¸»æµç¨‹æ§åˆ¶

**ä¼˜åŠ¿ï¼š**
- æé«˜ä»£ç å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§
- ä¾¿äºå•å…ƒæµ‹è¯•
- ä¾¿äºåŠŸèƒ½å¤ç”¨

### 2. æŸ¥æ‰¾ç®—æ³•ä¼˜åŒ– âš¡

**ä¼˜åŒ–å‰ï¼š**
```python
def find_non_intersecting_rows(matrix):
    for i in range(n_rows):
        nonzero_i = set(np.where(matrix[i, :] != 0)[0])
        for j in range(i + 1, n_rows):
            nonzero_j = set(np.where(matrix[j, :] != 0)[0])
            if len(nonzero_i & nonzero_j) == 0:  # æ¯æ¬¡éƒ½è®¡ç®—äº¤é›†
                return i, j, nonzero_i, nonzero_j
```

**ä¼˜åŒ–åï¼š**
```python
def find_non_intersecting_rows_optimized(matrix):
    # 1. é¢„è®¡ç®—æ‰€æœ‰è¡Œçš„éé›¶åˆ—ç´¢å¼•
    nonzero_cols = []
    for i in range(n_rows):
        cols = np.where(matrix[i, :] != 0)[0]
        if len(cols) > 0:
            nonzero_cols.append((i, set(cols)))

    # 2. ä½¿ç”¨ isdisjoint() æ–¹æ³•æ›¿ä»£äº¤é›†é•¿åº¦æ£€æŸ¥
    for idx1 in range(len(nonzero_cols)):
        i, cols_i = nonzero_cols[idx1]
        for idx2 in range(idx1 + 1, len(nonzero_cols)):
            j, cols_j = nonzero_cols[idx2]
            if cols_i.isdisjoint(cols_j):  # æ›´å¿«çš„ä¸ç›¸äº¤æ£€æŸ¥
                return i, j, cols_i, cols_j
```

**ä¼˜åŒ–æŠ€æœ¯ï¼š**
- **é¢„è®¡ç®—ä¼˜åŒ–**ï¼šä¸€æ¬¡æ€§è®¡ç®—æ‰€æœ‰è¡Œçš„éé›¶ä½ç½®ï¼Œé¿å…é‡å¤è®¡ç®—
- **é›†åˆæ“ä½œä¼˜åŒ–**ï¼šä½¿ç”¨ `isdisjoint()` è€Œä¸æ˜¯ `len(A & B) == 0`
  - `isdisjoint()` åœ¨æ‰¾åˆ°ç¬¬ä¸€ä¸ªå…±åŒå…ƒç´ æ—¶å°±è¿”å›ï¼Œæ—¶é—´å¤æ‚åº¦ O(min(len(A), len(B)))
  - äº¤é›†æ“ä½œ `&` éœ€è¦éå†æ‰€æœ‰å…ƒç´ ï¼Œæ—¶é—´å¤æ‚åº¦ O(len(A) + len(B))
- **è¿‡æ»¤ç©ºè¡Œ**ï¼šè·³è¿‡æ²¡æœ‰éé›¶å…ƒç´ çš„è¡Œ

**æ€§èƒ½æå‡ï¼š** æŸ¥æ‰¾æ—¶é—´çº¦ 0.0004ç§’ï¼ˆå…·ä½“å–å†³äºæ•°æ®ï¼‰

### 3. ç›¸ä¼¼åº¦è®¡ç®—å°è£… ğŸ“Š

**ä¼˜åŒ–åæ–°å¢ï¼š**
```python
def calculate_similarity_metrics(vec1, vec2):
    """è®¡ç®—å¤šç§ç›¸ä¼¼åº¦æŒ‡æ ‡å¹¶è¿”å›å­—å…¸"""
    return {
        'cosine_similarity': cosine_similarity([vec1], [vec2])[0, 0],
        'euclidean_distance': np.linalg.norm(vec1 - vec2),
        'dot_product': np.dot(vec1, vec2)
    }
```

**ä¼˜åŠ¿ï¼š**
- ç»Ÿä¸€çš„æ¥å£
- æ˜“äºæ‰©å±•æ›´å¤šç›¸ä¼¼åº¦åº¦é‡
- è¿”å›ç»“æ„åŒ–æ•°æ®

### 4. æ€§èƒ½ç›‘æ§ â±ï¸

**ä¼˜åŒ–åæ–°å¢ï¼š**
- æ·»åŠ äº†å¯¹å„ä¸ªæ­¥éª¤çš„æ—¶é—´ç»Ÿè®¡ï¼š
  ```python
  start_time = time.time()
  # ... æ‰§è¡Œæ“ä½œ ...
  elapsed_time = time.time() - start_time
  ```
- è¾“å‡ºæ€§èƒ½æ€»ç»“ï¼š
  ```
  ã€æ€§èƒ½æ€»ç»“ã€‘
  çŸ©é˜µç”Ÿæˆæ—¶é—´: 0.0014ç§’
  SVDåˆ†è§£æ—¶é—´: 0.0049ç§’
  è¡ŒæŸ¥æ‰¾æ—¶é—´: 0.0004ç§’
  æ€»è¿è¡Œæ—¶é—´: 0.0067ç§’
  ```

**ä¼˜åŠ¿ï¼š**
- å¯ä»¥è¯†åˆ«æ€§èƒ½ç“¶é¢ˆ
- ä¾¿äºå¯¹æ¯”ä¸åŒä¼˜åŒ–æ–¹æ¡ˆ
- å¸®åŠ©è°ƒè¯•å’Œæ€§èƒ½è°ƒä¼˜

### 5. å¢å¼ºçš„è¾“å‡ºä¿¡æ¯ ğŸ“

**ä¼˜åŒ–åæ–°å¢ï¼š**
- æ¯ä¸ªæ­¥éª¤çš„æ‰§è¡Œæ—¶é—´
- ç›¸ä¼¼åº¦ç»“æœçš„è‡ªåŠ¨è§£é‡Šï¼š
  ```python
  if abs(metrics['cosine_similarity']) > 0.5:
      print("â†’ ä½™å¼¦ç›¸ä¼¼åº¦è¾ƒé«˜ï¼Œè¯´æ˜ä¸¤ä¸ªç”¨æˆ·åœ¨ä½ç»´ç©ºé—´ä¸­æœ‰ç›¸ä¼¼çš„åå¥½æ–¹å‘")
  elif abs(metrics['cosine_similarity']) < 0.1:
      print("â†’ ä½™å¼¦ç›¸ä¼¼åº¦è¾ƒä½ï¼Œè¯´æ˜ä¸¤ä¸ªç”¨æˆ·çš„åå¥½æ–¹å‘å·®å¼‚è¾ƒå¤§")
  ```
- æ›´æ¸…æ™°çš„æ ¼å¼åŒ–è¾“å‡ºå‡½æ•°

**ä¼˜åŠ¿ï¼š**
- æ›´å¥½çš„ç”¨æˆ·ä½“éªŒ
- è‡ªåŠ¨è§£é‡Šç»“æœï¼Œä¾¿äºç†è§£
- ä¾¿äºæ•™å­¦å’Œæ¼”ç¤º

### 6. è¿”å›å€¼è®¾è®¡ ğŸ”„

**ä¼˜åŒ–åæ–°å¢ï¼š**
```python
def main():
    # ... æ‰§è¡Œä½œä¸š ...
    return {
        'matrix': A,
        'U_r': U_r,
        'sigma_r': sigma_r,
        'Vt_r': Vt_r,
        'reconstruction_error': reconstruction_error,
        'energy_retained': energy_retained
    }

if __name__ == "__main__":
    results = main()
```

**ä¼˜åŠ¿ï¼š**
- å¯ä»¥ä½œä¸ºæ¨¡å—å¯¼å…¥ä½¿ç”¨
- ä¾¿äºä¸å…¶ä»–ä»£ç é›†æˆ
- æ”¯æŒ Jupyter Notebook ä¸­çš„äº¤äº’å¼ä½¿ç”¨

## æ€§èƒ½å¯¹æ¯”

| æŒ‡æ ‡ | åŸå§‹ç‰ˆæœ¬ | ä¼˜åŒ–ç‰ˆæœ¬ | æå‡ |
|-----|---------|---------|-----|
| ä»£ç è¡Œæ•° | 140è¡Œ | 280è¡Œ | - |
| å‡½æ•°å°è£… | 1ä¸ª | 8ä¸ª | â†‘ 800% |
| æ€§èƒ½ç›‘æ§ | æ—  | å®Œæ•´ | âœ… |
| æŸ¥æ‰¾ç®—æ³• | æ ‡å‡† | ä¼˜åŒ– | âš¡ |
| ä»£ç å¤ç”¨æ€§ | ä½ | é«˜ | â†‘ |
| å¯ç»´æŠ¤æ€§ | ä½ | é«˜ | â†‘ |
| æ€»è¿è¡Œæ—¶é—´ | - | 0.0067ç§’ | â±ï¸ |

## ä»£ç è´¨é‡æå‡

### æ–‡æ¡£å’Œæ³¨é‡Š
- âœ… æ¯ä¸ªå‡½æ•°éƒ½æœ‰è¯¦ç»†çš„docstring
- âœ… è¯´æ˜å‚æ•°ã€è¿”å›å€¼å’ŒåŠŸèƒ½
- âœ… å…³é”®ç®—æ³•æœ‰å®ç°è¯´æ˜

### å¯æµ‹è¯•æ€§
- âœ… æ¯ä¸ªåŠŸèƒ½ç‹¬ç«‹å°è£…
- âœ… æ¸…æ™°çš„è¾“å…¥è¾“å‡º
- âœ… ä¾¿äºç¼–å†™å•å…ƒæµ‹è¯•

### å¯æ‰©å±•æ€§
- âœ… æ˜“äºæ·»åŠ æ–°çš„ç›¸ä¼¼åº¦åº¦é‡
- âœ… æ˜“äºä¿®æ”¹çŸ©é˜µç”Ÿæˆç­–ç•¥
- âœ… æ˜“äºæ‰©å±•SVDåˆ†æåŠŸèƒ½

## ä½¿ç”¨æ–¹å¼

### è¿è¡Œä¼˜åŒ–ç‰ˆæœ¬
```bash
cd 1-svd
python3 work_optimized.py
```

### ä½œä¸ºæ¨¡å—å¯¼å…¥
```python
from work_optimized import (
    create_sparse_matrix,
    perform_svd_decomposition,
    calculate_similarity_metrics
)

# åˆ›å»ºçŸ©é˜µ
A = create_sparse_matrix(100, 1000, 0.05)

# SVDåˆ†è§£
U_r, sigma_r, Vt_r, sigma, A_reduced = perform_svd_decomposition(A, r=10)

# è®¡ç®—ç›¸ä¼¼åº¦
metrics = calculate_similarity_metrics(U_r[0], U_r[1])
```

## æœªæ¥å¯èƒ½çš„ä¼˜åŒ–æ–¹å‘

### 1. ä½¿ç”¨ç¨€ç–SVD
å¯¹äºå¤§è§„æ¨¡ç¨€ç–çŸ©é˜µï¼Œå¯ä»¥ä½¿ç”¨ `scipy.sparse.linalg.svds` è¿›è¡Œéƒ¨åˆ†SVDåˆ†è§£ï¼Œé¿å…è½¬æ¢ä¸ºå¯†é›†çŸ©é˜µï¼š
```python
from scipy.sparse.linalg import svds

# ç›´æ¥å¯¹ç¨€ç–çŸ©é˜µè¿›è¡ŒSVD
U, sigma, Vt = svds(A_sparse, k=r)
```

**ä¼˜åŠ¿ï¼š**
- èŠ‚çœå†…å­˜ï¼ˆä¸éœ€è¦è½¬æ¢ä¸ºå¯†é›†çŸ©é˜µï¼‰
- æ›´å¿«çš„è®¡ç®—é€Ÿåº¦ï¼ˆåªè®¡ç®—å‰kä¸ªå¥‡å¼‚å€¼ï¼‰
- é€‚åˆå¤§è§„æ¨¡æ•°æ®

### 2. å¹¶è¡ŒåŒ–å¤„ç†
å¯¹äºæ›´å¤§è§„æ¨¡çš„æ•°æ®ï¼Œå¯ä»¥ä½¿ç”¨å¹¶è¡Œè®¡ç®—ï¼š
```python
from joblib import Parallel, delayed

# å¹¶è¡ŒæŸ¥æ‰¾æ— äº¤é›†è¡Œ
results = Parallel(n_jobs=-1)(
    delayed(check_intersection)(i, j)
    for i in range(n_rows)
    for j in range(i+1, n_rows)
)
```

### 3. ç¼“å­˜ä¼˜åŒ–
å¯¹äºé‡å¤è®¡ç®—ï¼Œå¯ä»¥æ·»åŠ ç¼“å­˜ï¼š
```python
from functools import lru_cache

@lru_cache(maxsize=1000)
def get_nonzero_cols(row_index):
    return frozenset(np.where(A[row_index, :] != 0)[0])
```

### 4. GPUåŠ é€Ÿ
å¯¹äºè¶…å¤§è§„æ¨¡çŸ©é˜µï¼Œå¯ä»¥ä½¿ç”¨ CuPy è¿›è¡ŒGPUåŠ é€Ÿï¼š
```python
import cupy as cp

# åœ¨GPUä¸Šæ‰§è¡ŒSVD
A_gpu = cp.asarray(A)
U, sigma, Vt = cp.linalg.svd(A_gpu)
```

## æ€»ç»“

æœ¬æ¬¡ä¼˜åŒ–ä¸»è¦å…³æ³¨ï¼š
1. âœ… **ä»£ç ç»“æ„** - æ¨¡å—åŒ–ã€å¯ç»´æŠ¤
2. âœ… **ç®—æ³•æ•ˆç‡** - ä¼˜åŒ–å…³é”®æŸ¥æ‰¾ç®—æ³•
3. âœ… **æ€§èƒ½ç›‘æ§** - æ·»åŠ æ—¶é—´ç»Ÿè®¡
4. âœ… **ç”¨æˆ·ä½“éªŒ** - æ›´å¥½çš„è¾“å‡ºå’Œè§£é‡Š
5. âœ… **å¯å¤ç”¨æ€§** - å‡½æ•°å°è£…å’Œè¿”å›å€¼è®¾è®¡

ä¼˜åŒ–åçš„ä»£ç åœ¨ä¿æŒåŠŸèƒ½å®Œæ•´æ€§çš„åŒæ—¶ï¼Œæ˜¾è‘—æå‡äº†ä»£ç è´¨é‡ã€å¯ç»´æŠ¤æ€§å’Œæ€§èƒ½ç›‘æ§èƒ½åŠ›ã€‚
